
<div class="nav-bar">
	<?php echo Phalcon_Tag::linkTo('index', 'Home') ?> » Documentation
</div>

<div class="doc-paragraph">
	<h2>Working with Models</h2>
	A model represents the information (data) of the application and the rules to manipulate that data.
	Models are primarily used for managing the rules of interaction with a corresponding database table.
	In most cases, each table in your database will correspond to one model in your application.
	The bulk of your application’s business logic will be concentrated in the models.
</div>

<div class="doc-paragraph">
	<?php echo Tag::classLink('Phalcon_Model_Base', 'Phalcon_Model') ?> is the base for the models
	in a Phalcon application. It provides database
	independence, basic CRUD functionality, advanced finding capabilities, and the ability
	to relate models to one another, among other services. Phalcon_Model avoids the need of
	having to use SQL statements because it translates dynamically to the respective database engine.
</div>

<div class="doc-paragraph highlightb">
	Models are intended to work on a database high layer of abstraction.
	If you need to work with databases at a lower level
	check out the <?php echo Phalcon_Tag::linkTo('documentation/db', 'Phalcon_Db') ?>
	component documentation.
</div>

<div class="doc-paragraph">
	<h3><a name="creating">Creating Models</a></h3>
	A model is a class that extends from Phalcon_Model_Base. It must be placed in the models directory.
	A model file must contain a single class; its class name should be in camel case notation:
</div>

<div class="doc-center">
<?php echo hyperlight('<?php

class Robots extends Phalcon_Model_Base
{

}

', 'php'); ?>
</div>

<div class="doc-paragraph">
	The above example showed us how to implement model "Robots".
	There isn’t much to this file – but note that the class Robots inherits from Phalcon_Model_Base -.
	Phalcon_Model supplies a great deal of functionality to your models for free,
	including basic database CRUD (Create, Read, Update, Destroy) operations, data validation,
	as well as sophisticated search support and the ability to relate multiple models to one another.
</div>

<div class="doc-paragraph">
	By default model "Robots" will refer to table "robots". If you want to manually specify another name
	for the mapping table, you can use the setSource method:
</div>

<?php echo hyperlight('<?php

class Robots extends Phalcon_Model_Base
{

  function initialize(){
     $this->setSource("the_robots");
  }

}

', 'php'); ?>

<div class="doc-paragraph">
	The model Robots now maps to "the_birds" table. The "initialize" method helps us to set up the model with custom behavior.
	This method is only called once during the request.
</div>

<div class="doc-paragraph">
	<h3><a name="understanding">Understanding Record To Objects</a></h3>
	Every instance of a model represents a row in the table. You can easily access record data by reading objects properties.
	For example, for a table "robots" with the next records:
</div>

<?php echo hyperlight('
mysql> select * from robots;
+----+------------+------------+------+
| id | name       | type       | year |
+----+------------+------------+------+
|  1 | Robotina   | mechanical | 1972 |
|  2 | Astro Boy  | mechanical | 1952 |
|  3 | Terminator | cyborg     | 2029 |
+----+------------+------------+------+
3 rows in set (0.00 sec)
', 'php'); ?>

<div class="doc-paragraph">
You could find a certain record by its primary key and then print its name:
</div>

<?php echo hyperlight('
//Find record with id=3
$robot = Robots::findFirst(3);

//Prints "Terminator"
echo $robot->name;

', 'iphp'); ?>

<div class="doc-paragraph">
Once the record is in memory, you can make modifications to it and then save changes:
</div>

<?php echo hyperlight('
$robot = Robots::findFirst(3);
$robot->name = "RoboCop";
$robot->save();

', 'iphp'); ?>


<div class="doc-paragraph">
As you can see, there is not need of use SQL statements or similar. Phalcon_Model provides high database abstraction for web applications.
</div>

<div class="doc-paragraph">
	<h3><a name="finding">Finding Records</a></h3>
	Phalcon_Model provide you several methods for doing the querying of records. The next examples will show you
	how to query one or more records from a model:
</div>

<?php echo hyperlight('<?php

//How many robots are there?
$robots = Robots::find();
echo "There are ", count($robots), "\n";

//How many mechanical robots are there?
$robots = Robots::find("type=\'mechanical\'");
echo "There are ", count($robots), "\n";

//Get and print virtual robots ordered by name
$robots = Robots::find(array("type=\'virtual\'", "order" => "name"));
foreach ($robots as $robot) {
   echo $robot->name, "\n";
}

//Get first 100 virtual robots ordered by name
$robots = Robots::find(array("type=\'virtual\'", "order" => "name", "limit" => 100));
foreach ($robots as $robot) {
   echo $robot->name, "\n";
}
', 'php'); ?>

<div class="doc-paragraph">
	You could also use the findFirst method to get only the first record matching the given conditions:
</div>

<?php echo hyperlight('<?php

//What\'s the first robot in robots table?
$robot = Robots::findFirst();
echo "The robot name is ", $robot->name, "\n";

//What\'s the first mechanical robot in robots table?
$robot = Robots::findFirst("type=\'mechanical\'");
echo "The first mechanical robot name is ", $robot->name, "\n";

//Get first virtual robot ordered by name
$robot = Robots::findFirst(array("type=\'virtual\'", "order" => "name"));
echo "The first virtual robot name is ", $robot->name, "\n";

', 'php'); ?>

<div class="doc-paragraph">
	Both "find" and "findFirst" can accept an associative array specifying the find options.
	The following example shows how it works:
</div>

<?php echo hyperlight('<?php

$robot = Robots::findFirst(array(
   "type=\'virtual\'",
   "order" => "name DESC",
   "limit" => 30
));

$robots = Robots::find(array(
   "conditions" => "type=?1",
   "bind" => array(1 => "virtual")
));

', 'php'); ?>

<div class="doc-paragraph">
	The available query options are:
</div>

<div class="doc-paragraph">
	<table width="95%" align="center" cellspacing="0">
		<tr>
			<th>Parameter</th>
			<th>Description</th>
			<th>Example</th>
		</tr>
		<tr>
			<td>conditions</td>
			<td>Search conditions for the find operation. Is used to extract only those records that fulfill a
			specified criterion. By default
			Phalcon_model assumes the first parameter are the conditions.</td>
			<td>"conditions" => "name LIKE 'steve%'"</td>
		</tr>
		<tr>
			<td>bind</td>
			<td>Bind is used together with options by replacing placeholders, espacing values increasing the security</td>
			<td>"bind" => array("status" => "A", "type" => "some-time")</td>
		</tr>
		<tr>
			<td>order</td>
			<td>Is used to sort the result-set. Use one or more fields separated by commas.</td>
			<td>"order" => "name DESC, status"</td>
		</tr>
		<tr>
			<td>limit</td>
			<td>Limit the results of the query to results between a certain number range</td>
			<td>"limit" => 10</td>
		</tr>
		<tr>
			<td>columns</td>
			<td>Specific columns we need to query. Use this ONLY on read-only resultsets.</td>
			<td>"columns" => "id, name"</td>
		</tr>
		<tr>
			<td>group</td>
			<td>Allows to collect data across multiple records and group the results by one or more columns</td>
			<td>"group" => "name, status"</td>
		</tr>
		<tr>
			<td>for_update</td>
			<td>With this option, Phalcon_Model reads the latest available data, setting exclusive locks
				on each row it reads</td>
			<td>"for_update" => true</td>
		</tr>
		<tr>
			<td>shared_lock</td>
			<td>With this option, Phalcon_Model reads the latest available data, setting shared locks
				on each row it reads</td>
			<td>"shared_lock" => true</td>
		</tr>
		<tr>
			<td>cache</td>
			<td>Cache the resulset, reducing the continuous access to the relational system</td>
			<td>"cache" => array("lifetime" => 3600, "key" => "my-find-key")</td>
		</tr>
	</table>
</div>

<div class="doc-paragraph">
	<h4><a name="resultsets">Model Resultsets</a></h4>
	While "findFirst" returns directly and instance of the called class in case of match some records, "find"
	method returns a <?php echo Tag::classLink("Phalcon_Model_Resultset") ?>. This is a special object
	that encapsulates all the resultset functionality like traversing, seek to a specific record, counting, etc.
	These objects are more powerful than standard arrays. One of its greatest features is that it only have once record in memory at the same time.
	This greatly helps reduce the amount of memory used by the application when working with large amounts of data.
</div>

<?php echo hyperlight('<?php

//Get all robots
$robots = Robots::find();

//Traversing with a foreach
foreach($robots as $robot){
  echo $robot->name, "\n";
}

//Traversing with a while
$robots->rewind();
while($robots->valid()){
  $robot = $robots->current();
  echo $robot->name, "\n";
  $robots->next();
}

//Count the resultset
echo count($robots);

//Alternative way to count the resultset
echo $robots->count();

//Move the internal cursor to the third robot
$robots->seek(2);
$robot = $robots->current()

//Access a robot by its position in the resultset
$robot = $robots[5];

//Check if there is a record in certain position
if (isset($robots[3]) {
   $robot = $robots[3];
}

//Get the first record in the resultset
$robot = robots->getFirst();

//Get the last record
$robot = robots->getLast();

', 'php'); ?>

<div class="doc-paragraph">
	Note that resultsets can be serialized to store it to a cache or some backend you want. But also note that
	this forces to Phalcon_Model to unroll each row in the resultset into a big array consuming more memory,
	at least for one moment.
</div>

<?php echo hyperlight('<?php

//Query all records from model parts
$parts = Parts::find();

//Store the resultset into a file
file_put_contents("cache.txt", serialize($parts));

//Get parts from file
$parts = unserialize(file_get_contents("cache.txt"));

//Traverse the parts
foreach ($parts as $part) {
   echo $part->id;
}

', 'php'); ?>

<div class="doc-paragraph">
	<h4><a name="binding">Binding Parameters</a></h4>
	Binding parameters is also supported in Phalcon_Model. The binding process impact the performance minimally
	but reduce the possibility to be attacked using SQL injection techniques. Both string and integer placeholders are supported.
	Binding parameters can simply be achieved as follows:
</div>

<?php echo hyperlight('<?php

//Query robots binding parameters with string placeholders
$conditions = "name = :name: AND type = :type:";
$parameters = array("name" => "Robotina", "type" => "maid");
$robots = Robots::find(array($conditions, "bind" => $parameters));

//Query robots binding parameters with integer placeholders
$conditions = "name = ?1 AND type = ?2";
$parameters = array(1 => "Robotina", 2 => "maid");
$robots = Robots::find(array($conditions, "bind" => $parameters));

//Query robots binding parameters with both string and integer placeholders
$conditions = "name = :name: AND type = ?1";
$parameters = array("name" => "Robotina", 1 => "maid");
$robots = Robots::find(array($conditions, "bind" => $parameters));

', 'php'); ?>

<div class="doc-paragraph">
	When use numeric placeholders define it as integers, by example: 1 or 2.
	In this case "1" or "2" are considered strings and not numbers, so the
	placeholder could not be sucessfully replaced.
</div>

<div class="doc-paragraph">
	With the MySQL adapter strings are automatically escaped using <a href="http://php.net/manual/en/mysqli.real-escape-string.php">mysqli_real_escape_string</a>.
	That function takes into account the connection charset, so its recommended define it in the connection
	parameters or in the MySQL server configuration.
</div>

<div class="doc-paragraph">
	Binding parameters is available for all the query methods (like find and findFirst) also
	the calculations methods (count, sum, average, etc).
</div>

<div class="doc-paragraph">
	<h4><a name="caching">Caching Resultsets</a></h4>
	Access to database systems is often one of the most common bottlenecks that reduces
	the performance of web applications. This is because of the complex connection procedures,
	among other things, that PHP must do in each request to obtain data from a database system.
	A well known technique to avoid the continuos access to databases is cache the resultsets
	obtained from the database in an intermediate and less crowded medium.
</div>

<div class="doc-paragraph">
	Phalcon_Model is integrated with the <?php echo Tag::classLink("Phalcon_Cache") ?> component
	to provide a fancy syntax caching resultsets. The first step to cache a resulset is
	define a default cache backend in the model manager:
</div>

<?php echo hyperlight('<?php

//Cache data for one day by default
$frontendOptions = array(
  "lifetime" => 86400
);

//Memcached connection settings
$backendOptions = array(
  "host" => "localhost",
  "port" => "11211"
);

//Create a memcached cache
$cache = Phalcon_Cache::factory("Data", "Memcached", $frontendOptions, $backendOptions);

//Set the cache to the models manager
Phalcon_Model_Manager::getDefault()->setCache($cache);

', 'php'); ?>

<div class="doc-paragraph">
	The above example gives you full control over the cache definition and customization.
	But it could be very verbose for most cases.
	If you are using models with <?php echo Tag::classLink("Phalcon_Controller_Front") ?>
	you could setup the cache configuration as part of the bootstrap configuration:
</div>

<?php echo hyperlight('

$front = Phalcon_Controller_Front::getInstance();

//Setting up framework config
$config = new Phalcon_Config(array(
   "database" => array(
      "adapter" => "Mysql",
      "host" => "localhost",
      "username" => "scott",
      "password" => "cheetah",
      "name" => "test_db"
   ),
   "models" => array(
      "cache" => array(
        "adapter" => "File",
        "cacheDir" => "../app/cache/",
        "lifetime" => 3600
      )
   ),
   "phalcon" => array(
      "controllersDir" => "../app/controllers/",
      "modelsDir" => "../app/models/",
      "viewsDir" => "../app/views/"
   )
));

//Set the configuration
$front->setConfig($config);

', 'iphp'); ?>

<div class="doc-paragraph">
	This will define the default cache options for all the caches in the application.
	Moreover, if you are using ini configuration files you need to add the following
	section to setup the cache settings:
</div>

<?php echo hyperlight('
[models]
cache.adapter = "Memcached"
cache.host = "localhost"
cache.port = 11211
cache.lifetime = 8600
', 'iphp'); ?>

<div class="doc-paragraph">
	Once the cache setup is properly defined you could cache resultsets as follows:
</div>

<?php echo hyperlight('<?php

//Get products without caching
$products = Products::find();

//Just cache the resultset. The cache will expire in 1 hour (3600 seconds)
$products = Products::find(array("cache" => true));

//Cache the resultset only for 5 minutes
$products = Products::find(array("cache" => 300));

//Cache the resultset only for 5 minutes
$products = Products::find(array("cache" => 300));

//Cache the resultset with a key pre-defined
$products = Products::find(array("cache" => array("key" => "my-products-key")));

//Cache the resultset with a key pre-defined and for 2 minutes
$products = Products::find(array(
   "cache" => array(
      "key" => "my-products-key",
      "lifetime" => 120
   )
));

//Using a custom cache
$products = Products::find(array("cache" => $myCache));

', 'php'); ?>

<div class="doc-paragraph">
	By default, Phalcon_Model will create a unique key to store the resultset
	by generating a md5 hash of the SQL select statement generated internally.
	This is very practical because it renews the resultset in case of some
	of the condition's parameters have changed. If you want to control your own
	cache keys you could use the "key" parameter as seen above.
</div>

<div class="doc-paragraph">
	Note that not all resultsets must be cached. Results that change very frequently
	should not be cached because of the records presented do not represent reality.
	The same way, those with a lot of records should not be cached as this may
	be counterproductive in terms of performance.
</div>

<div class="doc-paragraph">
	Caching could be also applied to resultsets generated using relationships:
</div>

<?php echo hyperlight('

//Query some post
$post = Post::findFirst();

//Get comments related to a post, also cache it
$comments = $post->getComments(array("cache" => true));

', 'iphp'); ?>

<div class="doc-paragraph">
	<h3><a name="relationships">Relationships between Models</a></h3>
	There are four types of multiple relationships: one-on-one, one-to-many, many-to-one and many-to-many.
	The relationship may be unidirectional or bidirectional, and each can be simple or by a combination of models.
	Normally the model manager manages foreign key constraints for these relationships, the definition of
	these helps the reliable data integrity and the easy finding of related records to a model.
	Through the implementation of relations is possible to access records relating to each record in a uniform way.
</div>

<div class="doc-paragraph">
	<h4><a name="unidirectional">Unidirectional relationships</a></h4>
	Unidirectional relations are those that are generated in relation to one another but not vice versa.
	Using the methods belongsTo, hasOne or hasMany states that one or more fields refer to equivalents in
	another model.
</div>

<div class="doc-paragraph">
	<h4><a name="bidirectional">Bidirectional relations</a></h4>
	The bidirectional relations build relationships in which each has a complementary and vice versa.
</div>

<div class="doc-paragraph">
	<h4><a name="defining-rels">Defining relationships</a></h4>
	In Phalcon, relationships must be defined in the "initialize" method of a model. There are 3 methods to
	define relationships, all of them requires 3 parameters, local fields, referenced model, referenced fields,
	these methods are:
</div>

<div class="doc-paragraph">
	<table width="95%" align="center" cellspacing="0">
		<tr>
			<th>Method</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>hasMany</td>
			<td>Defines a 1-n relationship</td>
		</tr>
		<tr>
			<td>hasOne</td>
			<td>Defines a 1-1 relationship</td>
		</tr>
		<tr>
			<td>belongsTo</td>
			<td>Defines a n-1 relationship</td>
		</tr>
	</table>
</div>

<div class="doc-paragraph">
	The following schema shows 3 tables whose relations will serve us as an example to explain the relationships:
</div>

<?php echo hyperlight('

CREATE TABLE `robots` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(70) NOT NULL,
  `type` varchar(32) NOT NULL,
  `year` int(11) NOT NULL,
  PRIMARY KEY (`id`)
);

CREATE TABLE `robots_parts` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `robots_id` int(10) NOT NULL,
  `parts_id` int(10) NOT NULL,
  `created_at` DATE NOT NULL,
  PRIMARY KEY (`id`),
  KEY `robots_id` (`robots_id`),
  KEY `parts_id` (`parts_id`)
);

CREATE TABLE `parts` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(70) NOT NULL,
  PRIMARY KEY (`id`)
);

', 'php'); ?>

<div class="doc-paragraph">
	The model "Robots" has many "RobotsParts". Similar case for model "Parts" that has many "RobotsParts".
	On the other hand "RobotsParts" belongs to "Robots" and "Parts" models as a one-to-many relation.
</div>

<div class="doc-paragraph">
	The models with their relations could be implemented as follows:
</div>

<?php echo hyperlight('<?php

class Robots extends Phalcon_Model_Base
{

  function initialize()
  {
     $this->hasMany("id", "RobotsParts", "robots_id");
  }

}

', 'php'); ?>

<?php echo hyperlight('<?php

class Parts extends Phalcon_Model_Base
{

  function initialize(){
     $this->hasMany("id", "RobotsParts", "parts_id");
  }

}

', 'php'); ?>

<?php echo hyperlight('<?php

class RobotsParts extends Phalcon_Model_Base
{

  function initialize(){
     $this->belongsTo("robots_id", "Robots", "id");
     $this->belongsTo("parts_id", "Parts", "id");
  }

}

', 'php'); ?>

<div class="doc-paragraph">
	The first parameter indicates the field of the local model that is making the association;
	the second indicates the name of the referenced model and the third field name in the referenced field.
	You could also use arrays to define multiple fields in the relationship.
</div>

<div class="doc-paragraph">
	<h4><a name="advantage-rels">Taking advantage of relationships</a></h4>
	When explicitly define the relationships between models,
	is easy to find records relating to a previously consulted.
</div>

<?php echo hyperlight('<?php

$robot = Robots::findFirst(2);
foreach ($robot->getRobotsParts() as $robotPart) {
	echo $robotPart->getParts()->name, "\n";
}

', 'php'); ?>

<div class="doc-paragraph">
	Phalcon uses the magic method __call to take advantage of relationships in an easier way.
	If the called method has a "get" prefix Phalcon_Model will return a findFirst/find result.
	The following example compares the use of magic method and its respective code doing it manually:
</div>

<table class="compare">
	<tr>
		<td width="50%">
<?php echo hyperlight('<?php

$robot = Robots::findFirst(2);

//Robots model has a 1-n (hasMany)
//relationship to RobotsParts then
$robotsParts = $robot->getRobotsParts();

//Only parts that match conditions
$robotsParts = $robot->getRobotsParts("created_at=\'2012-03-15\'");

$robotPart = RobotsParts::findFirst(1);

//RobotsParts model has a n-1 (belongsTo)
//relationship to RobotsParts then
$robot = $robotPart->getRobots();


', 'php'); ?>
		</td>
		<td width="50%">
<?php echo hyperlight('<?php

$robot = Robots::findFirst(2);

//Robots model has a 1-n (hasMany)
//relationship to RobotsParts then
$robotsParts = RobotsParts::find("robots_id=\'".$robot->id."\'");

//Only parts that match conditions
$robotsParts = RobotsParts::find("robots_id=\'".$robot->id."\' AND created_at=\'2012-03-15\'");

$robotPart = RobotsParts::findFirst(1);

//RobotsParts model has a n-1 (belongsTo)
//relationship to RobotsParts then
$robot = Robots::findFirst("id=\'".$robotPart->robots_id."\'");

', 'php'); ?>
		</td>
	</tr>
</table>

<div class="doc-paragraph">
	Prefix "get" is used to find/findFirst related records. You can also use "count" to return an integer value
	result of count the related records:
</div>

<?php echo hyperlight('<?php

$robot = Robots::findFirst(2);
echo "The robot have ", $robot->countRobotsParts(), " parts\n";

', 'php'); ?>

<div class="doc-paragraph">
	<h4><a name="virtual-fkeys">Virtual Foreign Keys</a></h4>
	By default, relationships does not act like database foreign keys, that is,
	if you try to insert/update a value not having a valid value on its
	referenced model, Phalcon will not throw a validation message or anything.
	You can modify this behavior by adding a fourth parameter when defining a relationship.
</div>

<div class="doc-paragraph">
	Let's change the RobotsPart model to use its relationships as foreign keys:
</div>

<?php echo hyperlight('<?php

class RobotsParts extends Phalcon_Model_Base
{

  function initialize()
  {
     $this->belongsTo("robots_id", "Robots", "id", array(
       "foreignKey" => true
     ));
     $this->belongsTo("parts_id", "Parts", "id", array(
       "foreignKey" => array(
          "message" => "The part_id does not exist on the parts model"
       )
     ));
  }

}

', 'php'); ?>

<div class="doc-paragraph">
	If you alter a belongsTo relationship to act as foreign key, it will validate
	that values inserted/updated on those fields have a valid value on the referenced model.
	On the other hand, if a hasMany/hasOne is altered it will validate that records
	cannot be deleted if that record is used on any referenced model.
</div>

<?php echo hyperlight('<?php

class Parts extends Phalcon_Model_Base
{

  function initialize()
  {
     $this->hasMany("id", "RobotsParts", "parts_id", array(
     	"foreignKey" => array(
     	   "message" => "The part cannot be deleted because other robots are using it"
     	)
     ));
  }

}

', 'php'); ?>

<div class="doc-paragraph">
	<h3><a name="calculations">Generating Calculations</a></h3>
	Calculations are helpers for the well known functions of database systems such as COUNT, SUM, MAX, MIN or AVG.
	Phalcon_Model allow to use this functions in an easier way:
</div>

<div class="doc-paragraph">
	Count examples:
</div>

<?php echo hyperlight('<?php

//How many employees are?
$rowcount = Employees::count();

//How many different areas are assigned to employees?
$rowcount = Employees::count(array("distinct" => "area"));

//How many employees are in the Testing area?
$rowcount = Employees::count("area=\'Testing\'");

//Count employees grouping results by their area
$group = Employees::count(array("group" => "area"));
foreach($group as $row){
   echo "There are ", $group->rowcount, " in ", $group->area;
}

//Count employees grouping by their area and ordering the result by count
$group = Employees::count(array("group" => "area", "order" => "rowcount"));

', 'php'); ?>

<div class="doc-paragraph">
	Sumatories examples:
</div>

<?php echo hyperlight('<?php

//How much are the salaries of all employees?
$total = Employees::sum(array("column" => "salary"));

//How much are the salaries of all employees in the Sales area?
$total = Employees::sum(array("column" => "salary", "conditions" => "area=\'Sales\'"));

//Generate a grouping of the salaries of each area
$group = Employees::sum(array("column" => "salary", "group" => "area"));
foreach($group as $row){
   echo "The sumatory of salaries of the ", $group->area, " is ", $group->sumatory;
}

//Generate a grouping of the salaries of each area ordering salaries from higher to lower
$group = Employees::sum(array("column" => "salary", "group" => "area", "order" => "sumatory DESC"));

', 'php'); ?>

<div class="doc-paragraph">
	Averages examples:
</div>

<?php echo hyperlight('<?php

//What is the average salary for all employees?
$average = Employees::average(array("column" => "salary"));

//What is the average salary for the Sales\'s area employees?
$average = Employees::average(array("column" => "salary", "conditions" => "area=\'Sales\'"));

', 'php'); ?>

<div class="doc-paragraph">
	Maximum/Minimum examples:
</div>

<?php echo hyperlight('<?php

//What is the oldest age of all employees?
$age = Employees::maximum(array("column" => "age"));

//What is the oldest of employees from the Sales area?
$age = Employees::maximum(array("column" => "age", "conditions" => "area=\'Sales\'"));

//What is the lowest salary of all employees?
$salary = Employees::minimum(array("column" => "salary"));

', 'php'); ?>

<div class="doc-paragraph">
	<h3><a name="creating-updating">Creating Updating/Records</a></h3>
	The method Phalcon_Model_Base::save() allows you to create/update records according to whether they already exist in the table associated with a model.
	The save method is called out internally by create and update methods of Phalcon_Model. For this to
	work as expected it is necessary to have properly defined a primary key in the entity to
	determine whether a record should be updated or created.
</div>

<div class="doc-paragraph">
	Also the method executes associated validators, virtual foreign keys and events that are defined in the model.
</div>

<?php echo hyperlight('$robot = new Robots();
$robot->type = "mechanical";
$robot->name = "Astro Boy";
$robot->year = 1952;
if($robot->save() == false){
   echo "Umh, We can\'t store robots right now: \n";
   foreach ($robot->getMessages() as $message) {
      echo $message, "\n";
   }
} else {
   echo "Great, a new robot was saved successfully!";
}
', 'iphp'); ?>

<div class="doc-paragraph">
	<h4><a href="validation-messages">Validation Messages</a></h4>
	Phalcon_Model has a message subsystem that allows a flexible way to output or store the validation messages generated
	in the insertion/updating processes. Each message consists of an instance of the class Phalcon_Model_Message.
	The set of messages generated can be gotten with the method getMessages().
</div>

<div class="doc-paragraph">
	Each message provides extended information like the field name that generated the message or the message type:
</div>

<?php echo hyperlight('
if ($robot->save() == false) {
   foreach ($robot->getMessages() as $message) {
      echo "Message: ", $message->getMessage();
      echo "Field: ", $message->getField();
      echo "Type: ", $message->getType();
   }
}', 'iphp'); ?>

<div class="doc-paragraph">
	The following types of validation messages can be generated by Phalcon_Model:
</div>

<div class="doc-paragraph">
	<table width="95%" align="center" cellspacing="0">
		<tr>
			<th>Type</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>PresenceOf</td>
			<td>Generated when a field with a not-null attribute on the database is trying to insert/update a null value</td>
		</tr>
		<tr>
			<td>ConstraintViolation</td>
			<td>Generated when a field part of a virtual foreign key is trying to insert/update a value that doesn't
			exist in the referenced model</td>
		</tr>
		<tr>
			<td>InvalidValue</td>
			<td>Generated when a validator failed due to an invalid value</td>
		</tr>
	</table>
</div>

<div class="doc-paragraph">
	<h4><a name="validation-events">Validation Events</a></h4>
	Models allow you to implement events that will be thrown when performing an insert or update. They help to
	define business rules for a certain model.
</div>

<div class="doc-paragraph">
	The following are the events supported by Phalcon_Model and their order of execution:
</div>

<div class="doc-paragraph">
	<table width="95%" align="center" cellspacing="0">
		<tr>
			<th>Operation</th>
			<th>Name</th>
			<th>Can stop operation?</th>
			<th>Explanation</th>
		</tr>
		<tr>
			<td>Inserting/Updating</td>
			<td>beforeValidation</td>
			<td>YES</td>
			<td>Is executed before the fields are validated for not nulls or foreign keys</td>
		</tr>
		<tr>
			<td>Inserting</td>
			<td>beforeValidationOnCreate</td>
			<td>YES</td>
			<td>Is executed before the fields are validated for not nulls or foreign keys when an insertion operation is being made</td>
		</tr>
		<tr>
			<td>Updating</td>
			<td>beforeValidationOnUpdate</td>
			<td>YES</td>
			<td>Is executed before the fields are validated for not nulls or foreign keys when an updating operation is being made</td>
		</tr>
		<tr>
			<td>Inserting/Updating</td>
			<td>onValidationFails</td>
			<td>YES (already stopped)</td>
			<td>Is executed after an integrity validator fails</td>
		</tr>
		<tr>
			<td>Inserting</td>
			<td>afterValidationOnCreate</td>
			<td>YES</td>
			<td>Is executed after the fields are validated for not nulls or foreign keys when an insertion operation is being made</td>
		</tr>
		<tr>
			<td>Updating</td>
			<td>afterValidationOnUpdate</td>
			<td>YES</td>
			<td>Is executed after the fields are validated for not nulls or foreign keys when an updating operation is being made</td>
		</tr>
		<tr>
			<td>Inserting/Updating</td>
			<td>afterValidation</td>
			<td>YES</td>
			<td>Is executed after the fields are validated for not nulls or foreign keys</td>
		</tr>
		<tr>
			<td>Inserting/Updating</td>
			<td>beforeSave</td>
			<td>YES</td>
			<td>Runs before the required operation over the database system</td>
		</tr>
		<tr>
			<td>Updating</td>
			<td>beforeUpdate</td>
			<td>YES</td>
			<td>Runs before the required operation over the database system only when an updating operation is being made</td>
		</tr>
		<tr>
			<td>Inserting</td>
			<td>beforeCreate</td>
			<td>YES</td>
			<td>Runs before the required operation over the database system only when an inserting operation is being made</td>
		</tr>
		<tr>
			<td>Updating</td>
			<td>afterUpdate</td>
			<td>NO</td>
			<td>Runs after the required operation over the database system only when an updating operation is being made</td>
		</tr>
		<tr>
			<td>Inserting</td>
			<td>afterCreate</td>
			<td>NO</td>
			<td>Runs after the required operation over the database system only when an inserting operation is being made</td>
		</tr>
		<tr>
			<td>Inserting/Updating</td>
			<td>afterSave</td>
			<td>NO</td>
			<td>Runs after the required operation over the database system</td>
		</tr>
	</table>
</div>

<div class="doc-paragraph">
	<h4><a name="business-rule">Implement a Business Rule</a></h4>
	When an insert, update or delete is executed, the model verifies if there are any methods
	with the names of the events listed in the table above.
</div>

<div class="doc-paragraph">
	We recommend that validation methods are declared protected to prevent that business logic
	implementation are exposed publicly.
</div>

<div class="doc-paragraph">
	The following example implements an event that validates the year to update or
	insert cannot be smaller than 0:
</div>

<?php echo hyperlight('<?php

class Robots extends Phalcon_Model_Base
{

    function beforeSave()
    {
        if ($this->year < 0) {
            echo "Year cannot be smaller than zero!";
            return false;
        }
    }

}

', 'php'); ?>

<div class="doc-paragraph">
	Some events allow returning false as an indication to stop the current operation. If an event doesn't return anything, Phalcon_Model will assume a true value.
</div>

<div class="doc-paragraph">
	<h4><a name="validating-data">Validating Data Integrity</a></h4>
	Phalcon_Model provides several events to validate data and implement business rules.
	The special "validation" event allows us to call built-in validators over the record.
	Phalcon implement a couple of built-in validators that can be used at this stage of validation.
	The following example shows how to use it:
</div>

<?php echo hyperlight('<?php

class Robots extends Phalcon_Model_Base
{

    function validation()
    {
       $this->validate("InclusionIn", array(
          "field" => "type",
          "domain" => array("Mechanical", "Virtual")
       ));
       $this->validate("Uniqueness", array(
          "field" => "name",
          "message" => "The robot name must be unique"
       ));
       if ($this->validationHasFailed() == true) {
          return false;
       }
    }

}

', 'php'); ?>

<div class="doc-paragraph">
	The above example performs a validation using the built-in validator "InclusionIn". It checks the value of the field "type"
	in a domain list. If the value is not included in the method then will fail returning false.
</div>

<div class="doc-paragraph">
	The following built-in validators are available:
</div>

<div class="doc-paragraph">
	<table width="95%" align="center" cellspacing="0">
		<tr>
			<th>Name</th>
			<th>Explanation</th>
			<th>Example</th>
		</tr>
		<tr>
			<td>Email</td>
			<td>Validates that field contains a valid email format</td>
			<td><?php echo Tag::classLink('Phalcon_Model_Validator_Email', 'Example') ?></td>
		</tr>
		<tr>
			<td>ExclusionIn</td>
			<td>Validates that a value is not within a list of possible values</td>
			<td><?php echo Tag::classLink('Phalcon_Model_Validator_Exclusionin', 'Example') ?></td>
		</tr>
		<tr>
			<td>InclusionIn</td>
			<td>Validates that a value is within a list of possible values</td>
			<td><?php echo Tag::classLink('Phalcon_Model_Validator_Inclusionin', 'Example') ?></td>
		</tr>
		<tr>
			<td>Numericality</td>
			<td>Validates that a field has a numeric format</td>
			<td><?php echo Tag::classLink('Phalcon_Model_Validator_Numericality', 'Example') ?></td>
		</tr>
		<tr>
			<td>Regex</td>
			<td>Validates that the value of a field matches a regular expression</td>
			<td><?php echo Tag::classLink('Phalcon_Model_Validator_Regex', 'Example') ?></td>
		</tr>
		<tr>
			<td>Uniqueness</td>
			<td>Validates that a field or a combination of a set of fields
 			are not present more than once in the existing records of the related table</td>
			<td><?php echo Tag::classLink('Phalcon_Model_Validator_Uniqueness', 'Example') ?></td>
		</tr>
	</table>
</div>

<div class="doc-paragraph">
	In addition to the built-in validatiors, you can define your own validations using model events:
</div>

<?php echo hyperlight('<?php

class Robots extends Phalcon_Model_Base
{

   function beforeSave()
   {
       if ($this->type == "Old") {
          $message = new Phalcon_Model_Message("Sorry, old robots are not allowed anymore", "type", "MyType");
          $this->appendMessage($message);
          return false;
       }
       return true;
   }

}

', 'php'); ?>

<div class="doc-paragraph">
	<h3><a name="deleting">Deleting Records</a></h3>
	The method Phalcon_Model_Base::delete allows to delete a record in memory. You can use it as follows:
</div>

<?php echo hyperlight('

$robot = Robots::findFirst(11);
if ($robot != false){
   if ($robot->delete() == false) {
      echo "Sorry, we can\'t delete the robot right now: \n";
      foreach ($robot->getMessages() as $message) {
         echo $message, "\n";
      }
   } else {
     echo "The robot was deleted successfully!";
   }
}

', 'iphp'); ?>

<div class="doc-paragraph">
	Also you can delete many records traversing a resultset by using a foreach:
</div>

<?php echo hyperlight('

foreach (Robots::find("type=\'mechanical\'") as $robot) {
   if ($robot->delete() == false) {
      echo "Sorry, we can\'t delete the robot right now: \n";
      foreach ($robot->getMessages() as $message) {
         echo $message, "\n";
      }
   } else {
     echo "The robot was deleted successfully!";
   }
}

', 'iphp'); ?>

<div class="doc-paragraph">
	The next events are available to define custom business rules that should to be
	executed when a delete operation is being made.
</div>

<div class="doc-paragraph">
	<table width="95%" align="center" cellspacing="0">
		<tr>
			<th>Operation</th>
			<th>Name</th>
			<th>Can stop operation?</th>
			<th>Explanation</th>
		</tr>
		<tr>
			<td>Deleting</td>
			<td>beforeDelete</td>
			<td>YES</td>
			<td>Runs before the delete operation is made</td>
		</tr>
		<tr>
			<td>Deleting</td>
			<td>afterDelete</td>
			<td>NO</td>
			<td>Runs after the delete operation was made</td>
		</tr>
	</table>
</div>

<div class="doc-paragraph">
	<h3><a name="transactions">Transactions</a></h3>
	When a process performs multiple operations on a database, sometimes is required
	that each run in a complete and satisfactory way. Data integrity is lost when operations
	are interrupted and not completed successfully. Transactions in software just try
	to avoid these situations.
</div>

<div class="doc-paragraph">
	Transactions in Phalcon basically let to separate the objects belonging to a transaction
	so that all operations carried out by them can maintain a consistent state and could be
	rolled back if required.
</div>

<?php echo hyperlight('
try {

 //Request a transaction
 $transaction = Phalcon_Transaction_Manager::get();

 $robot = new Robots();
 $robot->setTransaction($transaction);
 $robot->name = "WALL·E";
 $robot->created_at = date("Y-m-d");
 if ($robot->save() == false) {
    $transaction->rollback("Cannot save robot");
 }

 $robotPart = new RobotParts();
 $robotPart->setTransaction($transaction);
 $robotPart->type = "head";
 if ($robotPart->save() == false) {
    $transaction->rollback("Cannot save robot part");
 }

 //Everything goes fine, let\'s commit the transaction
 $transaction->commit();

} catch(Phalcon_Transaction_Failed $e) {
 echo "Failed, reason: ", $e->getMessage();
}

', 'iphp'); ?>

<div class="doc-paragraph">
	Transactions can be used to delete many records in a consistent way:
</div>

<?php echo hyperlight('

try {

  //Request a transaction
  $transaction = Phalcon_Transaction_Manager::get();

  //Get the robots will be deleted
  foreach (Robots::find("type=\'mechanical\'") as $robot) {
    $robot->setTransaction($transaction);
    if ($robot->delete() == false) {
       //Something goes wrong, we should to rollback the transaction
       foreach ($robot->getMessages() as $message) {
          $transaction->rollback($message->getMessage());
       }
    }
  }

  //Everything goes fine, let\'s commit the transaction
  $transaction->commit();

  echo "Robots were deleted successfully!";

} catch(Phalcon_Transaction_Failed $e){
  echo "Failed, reason: ", $e->getMessage();
}

', 'iphp'); ?>

<div class="doc-paragraph">
	Transactions are reused no matter from which part of the application is obtained the transaction object.
	Only when performing a commit or rollback the transaction will generate a new one.
</div>

<div class="doc-paragraph">
	<h3><a name="meta-data">Models Meta-Data</a></h3>
	To speed up development Phalcon_Model helps you to query fields and constraints from tables related
	to models. In this task, <?php echo Tag::classLink('Phalcon_Model_MetaData') ?>, plays an important role.
	A global instance of that class is created to manage and cache table meta-data.
</div>

<div class="doc-paragraph">
	Sometimes it is necessary to get those attributes when working with models. You can get a meta-data instance
	by this way:
</div>

<?php echo hyperlight('

$robot = new Robots();

//Get Phalcon_Model_Metadata instance
$metaData = $robot->getManager()->getMetaData();

//Get robots fields names
$attributes = $metaData->getAttributes($robot);
print_r($attributes);

//Get robots fields data types
$dataTypes = $metaData->getDataTypes($robot);
print_r($dataTypes);

', 'iphp'); ?>


<div class="doc-paragraph">
	<h4><a name="caching-metadata">Caching Meta-Data</a></h4>
	Once the application is in a production stage, it is not necessary to query the metadata of
	the table from the database system each time you use the table. This could be done
	caching the meta-data using any of the following adapters:
</div>

<div class="doc-paragraph">
	<table width="95%" align="center" cellspacing="0">
		<tr>
			<th>Adapter</th>
			<th>Description</th>
			<th>API</th>
		</tr>
		<tr>
			<td>Memory</td>
			<td>This adapter is used by default in Phalcon. The meta-data is cached
			only during the request. When it finishes, the meta-data are released as part
			of the normal memory of the request. This adapter is perfect when the application
			is in development so as to refresh the metadata in each request updating new fields added
			or modifications to existing ones. </td>
			<td><?php echo Tag::classLink('Phalcon_Model_MetaData_Memory') ?></td>
		</tr>
		<tr>
			<td>Session</td>
			<td>This adapter stores meta-data in the $_SESSION superglobal.
			This adapter is recommended only when the application is actually using
			a few number of models. The meta-data are refreshed everytime
			a new session starts. This also requires to start the session
			with session_start before use any of models.</td>
			<td><?php echo Tag::classLink('Phalcon_Model_MetaData_Session') ?></td>
		</tr>
		<tr>
			<td>Apc</td>
			<td>The Apc adapter uses the <a href="http://www.php.net/manual/en/book.apc.php">
			Alternative PHP Cache (APC)</a> to store
			the table meta-data. You can specify the lifetime of the data with options.
			This is the most recommended way to store meta-data when the application
			is in production stage. </td>
			<td><?php echo Tag::classLink('Phalcon_Model_MetaData_Apc') ?></td>
		</tr>
	</table>
</div>

<div class="doc-paragraph">
	If you want to have full control over the meta-data caching process.
	You could replace the active meta-data manager as follows:
</div>

<?php echo hyperlight('

//Create a meta-data manager with APC
$metaData = new Phalcon_Model_MetaData("Apc", array(
   "lifetime" => 3600,
   "suffix" => "my-suffix"
));

//Replace the active meta-data manager
Phalcon_Model_Manager::getDefault()->setMetaData($metaData);

', 'iphp'); ?>

<div class="doc-paragraph">
	If your application is using a ini configuration file together
	with <?php echo Tag::classLink('Phalcon_Controller_Front') ?>, add the following section
	to it:
</div>

<?php echo hyperlight('
[models]
metadata.adapter = "Apc"
metadata.suffix = my-suffix
metadata.lifetime = 3600
', 'iphp'); ?>

<div class="doc-paragraph">
	<h3><a name="logging">Logging Low-Level SQL Statements</a></h3>
	When we use high-level abstraction components to access databases (like this ORM),
	we could find difficulties to understand which statements are finally sent to the database system.
	Phalcon_Model is supported internally on another component called
	Phalcon_Db that provides logging capabilities to track all the SQL statements sent to the database.
</div>

<?php echo hyperlight('

$robot = new Robots();

$logger = new Phalcon_Logger("File", "app/logs/debug.log");

//Set the logger to the internal connection
$robot->getConnection()->setLogger($logger);

$robot->name = "Robby the Robot";
$robot->created_at = "1956-07-21"
if ($robot->save() == false) {
    echo "Cannot save robot";
}

$logger->close();

', 'iphp'); ?>

<div class="doc-paragraph">
	As above, the file <i>app/logs/debug.log</i> might contain the following:
</div>

<?php echo hyperlight('[Mon, 30 Apr 12 13:47:18 -0500][DEBUG][Resource Id #77] INSERT INTO robots (name, created_at) VALUES (\'Robby the Robot\', \'1956-07-21\')', 'php') ?>

<div class="doc-paragraph">
	<h3><a name="profiling">Profiling SQL Statements</a></h3>
	Thanks to the underlying component Phalcon_Model called <?php echo Phalcon_Tag::linkTo('documentation/db', 'Phalcon_Db') ?>,
	it's possible to profile the SQL statements generated by the ORM in order to analyze the performance of database operations.
	With this you can diagnose performance problems and to discover bottlenecks.
</div>

<?php echo hyperlight('<?php

//Create a profiler
$profiler = new Phalcon_Db_Profiler();

//Set the connection profiler
Phalcon_Db_Pool::getConnection()->setProfiler($profiler);

//Send some SQL statements to the database
Robots::find();
Robots::find(array("order" => "name");
Robots::find(array("limit" => 30);

foreach($profiler->getProfiles() as $profile){
   echo "SQL Statement: ", $profile->getSQLStatement(), "\n";
   echo "Start Time: ", $profile->getInitialTime(), "\n";
   echo "Final Time: ", $profile->getFinalTime(), "\n";
   echo "Total Elapsed Time: ", $profile->getTotalElapsedSeconds(), "\n";
}

', 'php'); ?>

<div class="doc-paragraph">
	Each generated profile contains the duration in miliseconds that takes
	each instruction to be completed, and the SQL generated as well.
</div>

<div class="nav-bar">
	<table width="90%" align="center">
		<tr>
			<td align="left">
				<?php echo Phalcon_Tag::linkTo('documentation/controllers', '← Using Controllers') ?>
			</td>
			<td align="right">
				<?php echo Phalcon_Tag::linkTo('documentation/views', 'Using Views →') ?>
			</td>
		</tr>
	</table>
</div>
